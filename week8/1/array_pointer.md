# 数组与指针 — 精炼参考（带你风格）

目的  
- 按你的风格整理：先给大框架（基础概念 / 核心知识 / 常见误区 / 相近内容归并），补充必要例子与快速检验代码，方便放入课堂笔记或翻看。

---

## 大框架（先览）
1. 基础概念（术语与直观含义）  
2. 核心知识（规则、行为与常见用法）  
3. 相近内容归并（&、*、退化、指针算术、sizeof、左值/右值、多维数组）  
4. 常见误区（逐条纠正）  
5. 小结与快速检验示例

---

## 1 基础概念（术语）
- 数组声明/类型：`int a[5];` —— 静态类型（声明处）是 `int[5]`（array of 5 int）。  
- 指针类型：`T *`（指向 T）；`T (*)[N]`（指向含 N 个 T 的数组）。  
- 指针值：具体的地址（例如 `(void*)0x7ff...`），属于某个指针类型。  
- 对象：内存中的实体，有地址与内容（指针变量本身也是对象，存地址）。  
- 退化 (decay)：数组名在多数表达式中转换为指向首元素的指针（值 = `&a[0]`），但有例外。  
- 取地址 `&x`：产生地址值，类型为“pointer to x 的类型”。  
- 解引用 `*p`：通过指针访问该地址上的对象，类型为去掉一层 `*`。

---

## 2 核心知识（规则与例子）
- 退化与例外  
  - 发生：函数实参、赋值右值、表达式参与等 → `T[N]` → `T *`（值 = `&a[0]`）。  
  - 不发生：`sizeof(a)`、`&a`、`_Alignof(a)` 等，上下文中 `a` 表示整个数组对象。  
  - 函数形参：`void f(int a[])` 等价 `void f(int *a)`（参数调整）。

- 下标与指针等价  
  - 标准定义：`a[i]` 等价 `*(a + i)`（等价指访问同一存储位置并返回相同 lvalue/value）。  
  - 前提：`a` 必须能作为指针使用（退化或本来是指针）。

- & 与 * 的“镜像”  
  - `&x`：值变为地址，类型变为 pointer-to-original-type。  
  - `*p`：值变为该地址处对象，类型去一层 pointer。  
  - 示例：
    ```c
    int x = 5;
    int *p = &x; // &x 是 int*（值），赋给 p（变量，类型 int*）
    int v = *p;  // *p 是 int（解引用得到 x 的值）
    ```

- 指针算术（步长）  
  - 对 `T *p`，`p + 1` 地址增加 `sizeof(T)` 字节。  
  - 因此 `int *` 加 1 跳到下一个 int；`int (*)[5]` 加 1 跳过整个 5 个 int 的数组（步长 = `sizeof(int[5])`）。

- sizeof 的行为  
  - 在定义处：`sizeof(a)` = `N * sizeof(T)`（数组总字节）。  
  - 在形参或数组退化处：`sizeof(a)` = 指针大小（例如 8）。

- 左值/右值与赋值  
  - 数组名在声明处不是可赋值的左值，不能写 `a = something;`。  
  - 指针变量可以被赋值（类型需兼容）。结构体可以整体赋值，数组不行。

- 多维数组（递归规则）  
  - `int b[3][4];` 类型 `int[3][4]`；`b` 在多数表达式退化为 `int (*)[4]`（指向第一行）；`b[i]` 是 `int[4]`（可再退化为 `int *` 指向该行首元素）。

---

## 3 相近内容归并（便于记忆）
- a（数组名）在多数表达式 → `int *`（值 = `&a[0]`）；但在 `&a`/`sizeof` 中 a 表示整个数组（`int[ N ]`）。  
- `a`（退化后的指针）与 `&a[0]` 的值相同，但类型可能不同（一个是 `T *`，另一个是 `T (*)[N]`）。  
- `*` 与 `[]` 关系：`a[i]` == `*(a + i)`；因此 `p[0]` 与 `*p` 等价（前提 p 合法）。  
- 指针层级：`int **pp;` —— pp 是指向 `int *` 的指针，`*pp` 类型是 `int *`，`**pp` 是 `int`。

---

## 4 常见误区（逐条纠正）
- 误：数组名就是指针（或 `int * const`）。  
  - 纠：数组类型与指针类型不同；数组名在许多表达式中退化为指针，但静态类型仍为 `T[N]`；数组名不能赋值。
- 误：`&a` 总是 `int **`。  
  - 纠：当 `a` 是数组时，`&a` 类型为 `T (*)[N]`（pointer-to-array）；只有当 `a` 本身是 `T *` 变量时，`&a` 才是 `T **`。
- 误：`a == a[0]` 或 `a == *a`。  
  - 纠：`a`（退化后）是地址；`a[0]` 是元素值；`*a == a[0]`，而不是 `a == a[0]`。
- 误：可以用 `sizeof` 在函数内取得数组长度。  
  - 纠：传入函数后的形参是指针，`sizeof` 只能得到指针大小。
- 误：`&a` 与 `a` 算术等价。  
  - 纠：虽地址数值相同，类型不同导致 `a+1` 与 `&a+1` 的步长不同。

---

## 5 小结要点（便于记忆）
- 声明处：数组是 `T[N]`；使用处（多数表达式）：退化为 `T*`（值为 `&a[0]`）。  
- `a[i]` == `*(a + i)`；`*a` == `a[0]`（前提 a 可作指针）。  
- `&a` 是 pointer-to-array；`&a[0]` 是 pointer-to-element。  
- `sizeof` 的结果依赖于 a 是否退化。  
- 数组不可作为赋值目标（不是可赋值左值）。

---

## 6 快速检验代码（保存并运行看行为）
```c
// filepath: /home/matthew/zju_cpl/test_array_pointer.c
#include <stdio.h>

void f(int a[]) { // a 实际为 int *
    printf("in f: sizeof(a) = %zu\n", sizeof(a)); // 指针大小
}

int main(void) {
    int a[5] = {0,1,2,3,4};
    printf("in main: sizeof(a) = %zu\n", sizeof(a));         // 5 * sizeof(int)
    printf("a = %p, &a = %p, &a[0] = %p\n", (void*)a, (void*)&a, (void*)&a[0]);
    printf("a+1 = %p, &a+1 = %p\n", (void*)(a+1), (void*)(&a+1)); // 步长不同
    f(a);
    printf("*a = %d, a[0] = %d\n", *a, a[0]); // 等价
    return 0;
}
```

---

如需我把此版直接写入工作区（覆盖原 md），我可以提交修改；或按你的“笔记风格”再做语言/排版微调。// filepath: /home/matthew/zju_cpl/week8/1/array_pointer.md
# 数组与指针 — 精炼参考（带你风格）

目的  
- 按你的风格整理：先给大框架（基础概念 / 核心知识 / 常见误区 / 相近内容归并），补充必要例子与快速检验代码，方便放入课堂笔记或翻看。

---

## 大框架（先览）
1. 基础概念（术语与直观含义）  
2. 核心知识（规则、行为与常见用法）  
3. 相近内容归并（&、*、退化、指针算术、sizeof、左值/右值、多维数组）  
4. 常见误区（逐条纠正）  
5. 小结与快速检验示例

---

## 1 基础概念（术语）
- 数组声明/类型：`int a[5];` —— 静态类型（声明处）是 `int[5]`（array of 5 int）。  
- 指针类型：`T *`（指向 T）；`T (*)[N]`（指向含 N 个 T 的数组）。  
- 指针值：具体的地址（例如 `(void*)0x7ff...`），属于某个指针类型。  
- 对象：内存中的实体，有地址与内容（指针变量本身也是对象，存地址）。  
- 退化 (decay)：数组名在多数表达式中转换为指向首元素的指针（值 = `&a[0]`），但有例外。  
- 取地址 `&x`：产生地址值，类型为“pointer to x 的类型”。  
- 解引用 `*p`：通过指针访问该地址上的对象，类型为去掉一层 `*`。

---

## 2 核心知识（规则与例子）
- 退化与例外  
  - 发生：函数实参、赋值右值、表达式参与等 → `T[N]` → `T *`（值 = `&a[0]`）。  
  - 不发生：`sizeof(a)`、`&a`、`_Alignof(a)` 等，上下文中 `a` 表示整个数组对象。  
  - 函数形参：`void f(int a[])` 等价 `void f(int *a)`（参数调整）。

- 下标与指针等价  
  - 标准定义：`a[i]` 等价 `*(a + i)`（等价指访问同一存储位置并返回相同 lvalue/value）。  
  - 前提：`a` 必须能作为指针使用（退化或本来是指针）。

- & 与 * 的“镜像”  
  - `&x`：值变为地址，类型变为 pointer-to-original-type。  
  - `*p`：值变为该地址处对象，类型去一层 pointer。  
  - 示例：
    ```c
    int x = 5;
    int *p = &x; // &x 是 int*（值），赋给 p（变量，类型 int*）
    int v = *p;  // *p 是 int（解引用得到 x 的值）
    ```

- 指针算术（步长）  
  - 对 `T *p`，`p + 1` 地址增加 `sizeof(T)` 字节。  
  - 因此 `int *` 加 1 跳到下一个 int；`int (*)[5]` 加 1 跳过整个 5 个 int 的数组（步长 = `sizeof(int[5])`）。

- sizeof 的行为  
  - 在定义处：`sizeof(a)` = `N * sizeof(T)`（数组总字节）。  
  - 在形参或数组退化处：`sizeof(a)` = 指针大小（例如 8）。

- 左值/右值与赋值  
  - 数组名在声明处不是可赋值的左值，不能写 `a = something;`。  
  - 指针变量可以被赋值（类型需兼容）。结构体可以整体赋值，数组不行。

- 多维数组（递归规则）  
  - `int b[3][4];` 类型 `int[3][4]`；`b` 在多数表达式退化为 `int (*)[4]`（指向第一行）；`b[i]` 是 `int[4]`（可再退化为 `int *` 指向该行首元素）。

---

## 3 相近内容归并（便于记忆）
- a（数组名）在多数表达式 → `int *`（值 = `&a[0]`）；但在 `&a`/`sizeof` 中 a 表示整个数组（`int[ N ]`）。  
- `a`（退化后的指针）与 `&a[0]` 的值相同，但类型可能不同（一个是 `T *`，另一个是 `T (*)[N]`）。  
- `*` 与 `[]` 关系：`a[i]` == `*(a + i)`；因此 `p[0]` 与 `*p` 等价（前提 p 合法）。  
- 指针层级：`int **pp;` —— pp 是指向 `int *` 的指针，`*pp` 类型是 `int *`，`**pp` 是 `int`。

---

## 4 常见误区（逐条纠正）
- 误：数组名就是指针（或 `int * const`）。  
  - 纠：数组类型与指针类型不同；数组名在许多表达式中退化为指针，但静态类型仍为 `T[N]`；数组名不能赋值。
- 误：`&a` 总是 `int **`。  
  - 纠：当 `a` 是数组时，`&a` 类型为 `T (*)[N]`（pointer-to-array）；只有当 `a` 本身是 `T *` 变量时，`&a` 才是 `T **`。
- 误：`a == a[0]` 或 `a == *a`。  
  - 纠：`a`（退化后）是地址；`a[0]` 是元素值；`*a == a[0]`，而不是 `a == a[0]`。
- 误：可以用 `sizeof` 在函数内取得数组长度。  
  - 纠：传入函数后的形参是指针，`sizeof` 只能得到指针大小。
- 误：`&a` 与 `a` 算术等价。  
  - 纠：虽地址数值相同，类型不同导致 `a+1` 与 `&a+1` 的步长不同。

---

## 5 小结要点（便于记忆）
- 声明处：数组是 `T[N]`；使用处（多数表达式）：退化为 `T*`（值为 `&a[0]`）。  
- `a[i]` == `*(a + i)`；`*a` == `a[0]`（前提 a 可作指针）。  
- `&a` 是 pointer-to-array；`&a[0]` 是 pointer-to-element。  
- `sizeof` 的结果依赖于 a 是否退化。  
- 数组不可作为赋值目标（不是可赋值左值）。

---

## 6 快速检验代码（保存并运行看行为）
```c
// filepath: /home/matthew/zju_cpl/test_array_pointer.c
#include <stdio.h>

void f(int a[]) { // a 实际为 int *
    printf("in f: sizeof(a) = %zu\n", sizeof(a)); // 指针大小
}

int main(void) {
    int a[5] = {0,1,2,3,4};
    printf("in main: sizeof(a) = %zu\n", sizeof(a));         // 5 * sizeof(int)
    printf("a = %p, &a = %p, &a[0] = %p\n", (void*)a, (void*)&a, (void*)&a[0]);
    printf("a+1 = %p, &a+1 = %p\n", (void*)(a+1), (void*)(&a+1)); // 步长不同
    f(a);
    printf("*a = %d, a[0] = %d\n", *a, a[0]); // 等价
    return 0;
}
```

---
